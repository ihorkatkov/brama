---
description: 
globs: 
alwaysApply: false
---
# Elixir Metaprogramming

<rule>
name: elixir_metaprogramming
description: Best practices for metaprogramming, macros, and compile-time code generation in Elixir
filters:
  - type: file_extension
    pattern: "\\.ex$|\\.exs$"

actions:
  - type: suggest
    message: |
      # Elixir Metaprogramming Best Practices

      ## When to Use Macros
      - Use macros only when necessary - prefer functions when possible
      - Consider macros for domain-specific languages (DSLs)
      - Use macros for compile-time optimizations or code generation
      - Use macros to reduce boilerplate while maintaining clear semantics
      
      ## Macro Design
      - Make macros hygienic by using `quote` with proper variable binding
      - Use `unquote` carefully to interpolate values within quoted expressions
      - Use `unquote_splicing` for handling lists of expressions
      - Keep macros simple and focused on a single transformation
      
      ## Code Clarity
      - Document macros extensively, explaining transformations
      - Provide examples of both input code and resulting expanded code
      - Consider providing both macro and function versions of an API
      - Make macro-generated code debuggable with meaningful line numbers
      
      ## AST Manipulation
      - Use pattern matching for safer AST transformations
      - Use `Macro.expand/2` and `Macro.expand_once/2` to handle nested macros
      - Validate macro inputs to provide clear errors at compile time
      - Use `prewalk` and `postwalk` from the `Macro` module for complex AST traversal
      
      ## Testing
      - Test macro expansion explicitly using `Macro.expand/2`
      - Verify that invalid inputs produce appropriate compile-time errors
      - Test the runtime behavior of code generated by macros
      - Check edge cases for macro expansion

examples:
  - input: |
      defmodule BadMacro do
        defmacro loggy(expr) do
          quote do
            IO.puts("Executing: #{unquote(Macro.to_string(expr))}")
            unquote(expr)
          end
        end
      end
      
      # Usage could lead to variable name collisions:
      # import BadMacro
      # result = "hello"
      # loggy(IO.puts(result))  # Potential variable conflict
    output: |
      defmodule BetterMacro do
        @moduledoc """
        Provides logging macros that safely handle variable scoping.
        """
        
        @doc """
        Logs the expression being executed and returns its result.
        
        ## Examples
            
            import BetterMacro
            
            loggy(IO.puts("hello"))
            # Output:
            # Executing: IO.puts("hello")
            # hello
        """
        defmacro loggy(expr) do
          expr_str = Macro.to_string(expr)
          
          quote do
            require Logger
            Logger.debug("Executing: " <> unquote(expr_str))
            unquote(expr)
          end
        end
        
        @doc """
        Creates a function with logging around its execution.
        
        ## Examples
        
            defmodule Example do
              import BetterMacro
              
              deflogged greet(name) do
                "Hello, #{name}!"
              end
            end
            
            Example.greet("World")
            # Logs: "Calling greet with args: [\"World\"]"
            # Returns: "Hello, World!"
        """
        defmacro deflogged(call, do: block) do
          {name, _, args} = call
          
          quote do
            def unquote(call) do
              require Logger
              Logger.debug("Calling #{unquote(name)} with args: #{inspect(unquote(args))}")
              unquote(block)
            end
          end
        end
      end
  
  - input: |
      defmodule RepetitiveCode do
        def process_user(user) do
          with {:ok, user} <- validate_user(user),
               {:ok, user} <- enrich_user(user),
               {:ok, user} <- save_user(user) do
            {:ok, user}
          else
            {:error, reason} -> {:error, reason}
          end
        end
        
        def process_order(order) do
          with {:ok, order} <- validate_order(order),
               {:ok, order} <- calculate_totals(order),
               {:ok, order} <- save_order(order) do
            {:ok, order}
          else
            {:error, reason} -> {:error, reason}
          end
        end
        
        # Many more similar functions with the same pattern...
      end
    output: |
      defmodule StreamlinedCode do
        @moduledoc """
        Demonstrates efficient use of macros to reduce repetitive patterns.
        """
        
        defmodule Pipeline do
          @moduledoc """
          Provides macros for creating error-handling pipelines.
          """
          
          @doc """
          Creates a processing pipeline that safely handles errors.
          
          ## Examples
              
              process_pipeline :process_user, [
                :validate_user,
                :enrich_user,
                :save_user
              ]
          """
          defmacro process_pipeline(name, steps) do
            args = quote do: [data]
            
            pipeline = Enum.reduce(steps, quote(do: {:ok, data}), fn step, acc ->
              quote do
                with unquote(acc) do
                  unquote(step)(data)
                end
              end
            end)
            
            quote do
              def unquote(name)(unquote_splicing(args)) do
                unquote(pipeline)
              end
            end
          end
        end
        
        import Pipeline
        
        @doc """
        Processes a user through validation, enrichment, and saving.
        
        Returns `{:ok, user}` on success or `{:error, reason}` on failure.
        """
        process_pipeline :process_user, [
          &validate_user/1,
          &enrich_user/1,
          &save_user/1
        ]
        
        @doc """
        Processes an order through validation, calculation, and saving.
        
        Returns `{:ok, order}` on success or `{:error, reason}` on failure.
        """
        process_pipeline :process_order, [
          &validate_order/1,
          &calculate_totals/1,
          &save_order/1
        ]
        
        # Function implementations...
      end

metadata:
  priority: high
  version: 1.0
</rule>

<rule>
name: elixir_no_direct_macro_implementation
description: Restrictions on direct macro implementation to ensure proper review and necessity evaluation
filters:
  - type: file_extension
    pattern: "\\.ex$|\\.exs$"

actions:
  - type: suggest
    message: |
      # Macro Implementation Policy

      ## Core Policy
      - Never implement macros directly without user consultation
      - Always prefer regular functions over macros when possible
      - Seek explicit user approval for macro implementation

      ## Process
      1. When identifying a potential macro use case:
         - Present the use case to the user
         - Explain why a macro might be needed
         - Propose alternative solutions using regular functions
      
      2. Only proceed with macro implementation after:
         - User explicitly approves the macro approach
         - Regular function alternatives have been considered
         - The necessity of compile-time behavior is confirmed

      ## Exceptions
      - None. All macro implementations require user consultation

examples:
  - input: |
      # Instead of directly implementing a macro:
      defmodule DirectMacro do
        defmacro auto_log(do: block) do
          quote do
            IO.puts("Starting execution")
            result = unquote(block)
            IO.puts("Finished execution")
            result
          end
        end
      end
    output: |
      # First propose a regular function solution:
      defmodule RegularApproach do
        def with_logging(fun) do
          IO.puts("Starting execution")
          result = fun.()
          IO.puts("Finished execution")
          result
        end
      end
      
      # Then discuss with user if a macro is truly needed for compile-time benefits:
      """
      We could implement this as a macro if you need compile-time optimizations or AST manipulation.
      Would you like to explore the macro approach? Here are the trade-offs:
      
      Regular function benefits:
      - Simpler to understand and maintain
      - More flexible at runtime
      - Easier to test
      
      Macro potential benefits:
      - Compile-time optimizations
      - Custom syntax
      - Zero runtime overhead
      
      How would you like to proceed?
      """

metadata:
  priority: high
  version: 1.0
</rule> 